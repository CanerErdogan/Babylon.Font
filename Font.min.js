var __awaiter=this&&this.__awaiter||function(e,n,t,o){return new(t||(t=Promise))((function(s,r){function i(e){try{a(o.next(e))}catch(e){r(e)}}function c(e){try{a(o.throw(e))}catch(e){r(e)}}function a(e){var n;e.done?s(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(i,c)}a((o=o.apply(e,n||[])).next())}))};const{Vector3:Vector3,Curve3:Curve3,MeshBuilder:MeshBuilder,Mesh:Mesh,TransformNode:TransformNode}=BABYLON,universalCache=new WeakMap;export default function Font(e){return universalCache.has(e)||universalCache.set(e,new Map),GlyphFactory(e)}function GlyphFactory(e){const n=universalCache.get(e);function t(t,o=0,s=0){t=Array.from(t)[0];let r=n.get(t);return void 0===r&&(r=parse(e,t),n.set(t,r)),r(o,s)}return t.otFont=e,t.cache=n,t.measure=CharMeasureFactory(e),t.mesh=TextMeshFactory(e),t}function CharMeasureFactory(e){return function(n){const t=e.getPath(n,0,0,1).getBoundingBox(),o=e.charToGlyph(n);return{x1:t.x1,x2:t.x2,z1:-1*t.y2,z2:-1*t.y1,advanceWidth:o.advanceWidth/e.unitsPerEm}}}function CharMeshFactory(e){return function(n){const t=[];for(const{shape:o,holes:s}of e){const e=MeshBuilder.CreatePolygon("",{shape:o,holes:s,depth:n,sideOrientation:Mesh.DOUBLESIDE});t.push(e)}if(t.length)return Mesh.MergeMeshes(t,!0)||void 0}}function TextMeshFactory(e){return function(n,t=0,o=0,s=0,r={}){var i,c,a,u,h;const f=Font(e),l=n.split("\n");let d=0,p=0;const y=new TransformNode(""),C=new TransformNode("");C.parent=y;for(const e of l){let n=0;for(const l of e){let e;try{e=f(l,(null===(c=null===(i=r)||void 0===i?void 0:i[l])||void 0===c?void 0:c.ppc)?r[l].ppc:o,(null===(u=null===(a=r)||void 0===a?void 0:a[l])||void 0===u?void 0:u.eps)?r[l].eps:s).mesh(t)}catch(e){return null===(h=C)||void 0===h||h.dispose(),y}e&&(e.position.set(n,0,p),e.parent=C,e.metadata={char:l}),n+=f.measure(l).advanceWidth,d=Math.max(n,d)}p-=1}const g=C.getHierarchyBoundingVectors();return C.rotation.x=-Math.PI/2,C.position.x=-(g.max.x-g.min.x)/2,C.position.y=(g.max.z-g.min.z)/2-e.ascender/(e.ascender-e.descender),C.position.z=-(g.max.y-g.min.y)/2,y}}function parse(e,n){const t=toInstructions(e.getPath(n,0,0,1).commands,e.outlinesFormat);return function(e,n){const o=new Set;for(const s of t){const t=toVertices(s.fillInstruction,e,n),r=Array();for(const t of s.holeInstructions)r.push(toVertices(t,e,n));o.add({shape:t,holes:r})}return{data:o,mesh:CharMeshFactory(o)}}}function toVertices(e,n,t){const o=[];for(const t of e)t instanceof Function?o.push(...t(n)):o.push(t);return dedupNearbyVertices(o,t)}function toInstructions(e,n){const t=[];let o=[];const s=[],r=[],i=[];let c=[];for(const a of e)switch(a.type){case"M":{const e=new Vector3(a.x,0,-a.y);o=[e],c=[e],i.push(c);break}case"L":{const e=new Vector3(a.x,0,-a.y);o.push(e),c.push(e);break}case"Q":{const e=o[o.length-1],n=n=>Curve3.CreateQuadraticBezier(e,new Vector3(a.x1,0,-a.y1),new Vector3(a.x,0,-a.y),n).getPoints();o.push(...n(0)),c.push(n);break}case"C":{const e=o[o.length-1],n=n=>Curve3.CreateCubicBezier(e,new Vector3(a.x1,0,-a.y1),new Vector3(a.x2,0,-a.y2),new Vector3(a.x,0,-a.y),n).getPoints();o.push(...n(0)),c.push(n);break}case"Z":{const e=isPolygonCCW(o=dedupNearbyVertices(o,0));("cff"==n?!e:e)?r.push(t.length):s.push(t.length),t.push(o);break}}const a=groupFillAndHoles(t,s,r),u=new Set;for(const e of a){const n=i[e.fillIndex],t=new Set;for(const n of e.holeIndices)t.add(i[n]);u.add({fillInstruction:n,holeInstructions:t})}return u}function groupFillAndHoles(e,n,t){const o=new Set;for(const[s,r]of e.entries())if(n.indexOf(s)>-1){const n=r,i=new Set;e:for(const o of t){const t=e[o];if(isInside(t,n)){for(const n of i){const o=e[n];if(isInside(t,o))continue e;isInside(o,t)&&i.delete(n)}i.add(o)}}o.add({fillIndex:s,holeIndices:i})}return o}function dedupNearbyVertices(e,n){const t=[];for(const[o,s]of e.entries())0!==o&&s.equalsWithEpsilon(t[t.length-1],n)||t.push(s);if(t[t.length-1].equalsWithEpsilon(t[0],n)&&t.pop(),t.length<3)throw new Error("over decimated; hint: use smaller {eps}");return t}function isLineIntersect(e,n,t,o){return isCCW(e,n,t)!==isCCW(e,n,o)&&isCCW(t,o,e)!==isCCW(t,o,n)}function isCCW(e,n,t){return n.subtract(e).cross(t.subtract(e)).y<0}function isPolygonCCW(e){let n=0,t=0;for(const[o,s]of e.entries())s.x>n&&(n=s.x,t=o);const o=e[t];return isCCW(e[0==t?e.length-1:t-1],o,e[t==e.length-1?0:t+1])}function isInside(e,n){for(const[t,o]of e.entries()){const s=e[(t+1)%e.length];for(const[e,t]of n.entries()){if(isLineIntersect(o,s,t,n[(e+1)%n.length]))return!1}}return isPointInsidePolygon(e[0],n)}function isPointInsidePolygon(e,n){let t=0,o=new Vector3(e.x+1,0,e.z);for(const[s,r]of n.entries()){const i=n[(s+1)%n.length];isLineIntersect(e,o,r,i)&&(t+=isCCW(e,r,i)?1:-1)}return t%2!=0}Font.FromUrl=function(e){return __awaiter(this,void 0,void 0,(function*(){return new Promise((n,t)=>{opentype.load(e,(e,o)=>{e?t(e):n(Font(o))})})}))};