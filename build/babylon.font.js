import*as t from"@assemblyscript/loader";class e{wasm;constructor(t){this.wasm=t}static async Build(s){s??=new URL("optimized.wasm",import.meta.url).toString();const o=await t.instantiate(fetch(s),{});return new e(o)}encode(t,e){const s=new DataView(e);let o=0,r=0,a=0;const n="M".codePointAt(0),i="L".codePointAt(0),c="Q".codePointAt(0),l="C".codePointAt(0);for(const e of t){let t=e.type.codePointAt(0);switch(s.setUint8(o,t),o++,t){case n:case i:s.setFloat64(o,e.x,!0),o+=8,s.setFloat64(o,e.y,!0),o+=8,r=e.x,a=e.y;break;case c:s.setFloat64(o,r,!0),o+=8,s.setFloat64(o,a,!0),o+=8,s.setFloat64(o,e.x1,!0),o+=8,s.setFloat64(o,e.y1,!0),o+=8,s.setFloat64(o,e.x,!0),o+=8,s.setFloat64(o,e.y,!0),o+=8,r=e.x,a=e.y;break;case l:s.setFloat64(o,r,!0),o+=8,s.setFloat64(o,a,!0),o+=8,s.setFloat64(o,e.x1,!0),o+=8,s.setFloat64(o,e.y1,!0),o+=8,s.setFloat64(o,e.x2,!0),o+=8,s.setFloat64(o,e.y2,!0),o+=8,s.setFloat64(o,e.x,!0),o+=8,s.setFloat64(o,e.y,!0),o+=8,r=e.x,a=e.y}}return o}compileEncoded(t,e,s,o,r){if(o=Math.max(0,Math.min(255,Math.round(o))),r=Math.abs(r),t!==this.wasm.exports.memory.buffer){const e=this.wasm.exports.memory.buffer;for(let s=0,o=t.byteLength;s<o;++s)e[s]=t[s]}const a=this.wasm.exports.compile(e,s,o,r),n=new Float64Array(this.wasm.exports.memory.buffer),i=this.wasm.exports.__getUint32Array(a),c=[];for(let t=0;t<i.length;t++){const e={fill:[],holes:[]};if(0===i[t])break;const s=this.wasm.exports.__getUint32Array(i[t]);for(const t of s){if(0===t)break;const s=this.wasm.exports.__getUint32Array(t);let o;0===e.fill.length?o=e.fill:e.holes.push(o=[]);for(const t of s){if(0===t)break;o.push([n[t>>>3],n[1+(t>>>3)]])}}c.push(e)}return c}compile(t,e,s,o){const r=this.wasm.exports.memory.buffer,a=this.encode(t,this.wasm.exports.memory.buffer);return this.compileEncoded(r,a,e,s,o)}}class s{raw;compiler;constructor(t,e){this.raw=t,this.compiler=e}static async Install(t,e,o){const r=await o.load(t);return new s(r,e)}measure(t,e){return new r(this,t,e)}static Compile(t,e,s,o,r){const a=t.raw.getPath(e,0,0,s).commands,n=t.raw.outlinesFormat;return t.compiler.compile(a,n,o,r*s)}}class o{babylon;earcut;constructor(t,e){this.babylon=t,this.earcut=e}createFromShapes(t,e,s){const o=[],r=t=>new this.babylon.Vector3(t[0],0,-t[1]);for(const{fill:a,holes:n}of t){const t=this.babylon.MeshBuilder.CreatePolygon("",{...e,shape:a.map(r),holes:n.map((t=>t.map(r)))},s,this.earcut);o.push(t)}return o.length>0?this.babylon.Mesh.MergeMeshes(o,!0,!0):null}create({font:t,text:e,size:o=100,ppc:r=2,eps:a=.001,...n},i){const c=s.Compile(t,e,o,r,a);return this.createFromShapes(c,n,i)}}class r{font;name;size;constructor(t,e,s){this.font=t,this.name=e,this.size=s}get ascender(){return this.font.raw.ascender/this.font.raw.unitsPerEm*this.size}get descender(){return this.font.raw.descender/this.font.raw.unitsPerEm*this.size}get advanceWidth(){return this.font.raw.getAdvanceWidth(this.name,this.size)}}export{e as Compiler,s as Font,r as Metrics,o as TextMeshBuilder};
